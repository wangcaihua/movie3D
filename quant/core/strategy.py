#!/usr/bin/python
# -*- coding: utf-8 -*-


import queue
from typing import List, Generator, Optional
from abc import ABCMeta, abstractmethod

from quant.core.datahandler import DataHandler
from quant.core.portfolio import Portfolio
from quant.core.event import DataEvent, Signal, SignalEvent

import logging

logger = logging.getLogger(__name__)


class StrategyRule(object, metaclass=ABCMeta):
    def __init__(self, portfolio: Portfolio):
        self.portfolio: Portfolio = portfolio
        self.events: queue.Queue = portfolio.events
        self.symbol_list: List[str] = portfolio.symbol_list
        self.data_handler: DataHandler = portfolio.data_handler

    @property
    def rule_id(self) -> str:
        raise NotImplementedError("Should implement rule_id")

    @abstractmethod
    def handle(self, event: DataEvent) -> Generator[Signal, None, None]:
        raise NotImplementedError("Should implement handle(event: DataEvent)")


class Strategy(object, metaclass=ABCMeta):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OHLCV) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to where the data came from,
    since it obtains the bar tuples from a queue object.
    """

    def __init__(self, portfolio: Portfolio):
        self.portfolio: Portfolio = portfolio
        self.events: queue.Queue = portfolio.events
        self.symbol_list: List[str] = portfolio.symbol_list
        self.data_handler: DataHandler = portfolio.data_handler
        self.rules: List[StrategyRule] = []

    def regist(self, rule: StrategyRule):
        self.rules.append(rule)

    def on_data(self, event: DataEvent):
        signals = {}
        for rule in self.rules:
            for signal in rule.handle(event):
                if signal is not None:
                    if signal.symbol in signals:
                        signals[signal.symbol].append(signal)
                    else:
                        signals[signal.symbol] = [signal]

        deduplicated_signals = []
        if signals:
            for symbol in signals:
                if len(signals[symbol]) > 1:
                    signals[symbol].sort(key=Signal.cmp_key, reverse=True)
                deduplicated_signals.append(signals[symbol][0])

            self.events.put(SignalEvent(event.timestamp, deduplicated_signals))
